---
title: 内存管理——内存映射
date: 2021-07-24 17:34:43
toc: true #是否显示文章目录
categories: "内存管理" #分类
tags: #标签
	- linux
	- mem
---

## 1.分段机制

![分段机制](分段机制.png)

&emsp;&emsp;**分段**(Segmentation)：是人们最开始使用的一种方法，基本思路是将程序所需要的内存地址空间大小的虚拟空间映射到某个物理地址空间。

&emsp;&emsp;每个程序都有其独立的虚拟的独立的进程地址空间，可以看到程序A和B的虚拟地址空间都是从0x00000000开始的。将两块大小相同的虚拟地址空间和实际物理地址空间一一映射，即虚拟地址空间中的每个字节对应于实际地址空间中的每个字节，这个映射过程由软件来设置映射的机制，实际的转换由硬件来完成。

&emsp;&emsp;这种分段的机制解决了之前提到的3个问题中的进程地址空间隔离和程序地址重定位的问题。

&emsp;&emsp;程序A和程序B有自己独立的虚拟地址空间，而且该虚拟地址空间被映射到了互相不重叠的物理地址空间，如果程序A访问虚拟地址空间的地址不在0x00000000-0x00A00000这个范围内，那么内核就会拒绝这个请求，所以它解决了隔离地址空间的问题。

&emsp;&emsp;应用程序A只需要关心其虚拟地址空间0x00000000-0x00A00000，而其被映射到哪个物理地址无需关心，所以程序永远按照这个虚拟地址空间来放置变量，代码，不需要重新定位。

&emsp;&emsp;虽然分段机制解决了上面两个问题，但是对于内存效率问题仍然无能为力。因为这种内存映射机制仍然是以程序为单位，当内存不足时仍然需要将整个程序交换到磁盘，这样内存使用的效率仍然很低。

&emsp;&emsp;那么，怎么才算高效率的内存使用呢。事实上，根据程序的局部性运行原理，一个程序在运行的过程当中，在某个时间段内，只有一小部分数据会被经常用到。所以需要更加小粒度的内存分割和映射方法，所以，另一种将虚拟地址转换为物理地址的方法——分页机制应运而生了。

&emsp;&emsp;由于分段和分页都是划分进程物理地址空间，区别在于分段是给每个进程分配不同的线性地址空间，而分页是把线性地址空间映射到不同的物理地址空间，所以，分页机制就已经足够实现内存管理的功能。

&emsp;&emsp;而且，分段机制的起源是intel 8086的CPU体系结构ALU运算宽度与地址总线宽度不一致（16位和20位），而后续的intel处理器又为了向上兼容的遗留产物 。

<center>表1-1 intel处理器</center>

| 型号  | 位宽 | 总线位宽 | 地址位宽 | 寻址范围 | 备注                                                     |
| ----- | ---- | -------- | -------- | -------- | -------------------------------------------------------- |
| 4004  | 4    | 4        | —        | 640B     | 1971/11/15                                               |
| 8008  | 8    | 8        | —        | 16KB     | 1972/04/01                                               |
| 8080  | 8    | 8        | 16       | 64KB     | 1974/04/01                                               |
| 8086  | 16   | 16       | 20       | 1MB      | 1978/06/08                                               |
| 8088  | 16   | 8        | 20       | 1MB      | 1979/06/01                                               |
| 80186 | 16   | 16       | 20       | 1MB      | 1982年，比8086多了几条指令                               |
| 80286 | 16   | 16       | 24       | 16MB     | 1982年，内存保护模式，多用户多任务                       |
| 80386 | 32   | 32       | 32       | 4GB      | 1985年，支持虚拟内存                                     |
| 80486 | 32   | 32       | 32       | 4GB      | 1989年，集成数字协处理器80387和8KB高速缓存，采用RISC技术 |

&emsp;&emsp;因此，几乎所有RISC体系结构的处理器都不支持分段机制，而只采用了分页机制。所以，linux为了移植性和简化内存管理（共享一组线性地址），只在80x86结构下才使用分段机制。这就是为什么linux没有线性地址，而只有虚拟地址和物理地址的原因。

## 2.分页机制

&emsp;&emsp;**分页**机制：把内存地址空间分为若干个很小的固定大小的页，每一页的大小由内存决定，就像Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。

&emsp;&emsp;试想一下，如果将磁盘空间分成N等份，每一份的大小(一个Block)是1M，如果想存储在磁盘上的文件是1K字节，那么其余的999字节便浪费了。所以需要更加细粒度的磁盘分割方式，可以将Block设置得小一点。

&emsp;&emsp;linux一般页的大小是4KB，并把进程的地址空间按页分割，把常用的数据和代码页装载到内存中，不常用的代码和数据保存在磁盘中，以一个例子来说明，如下图：

![分页机制](分页机制.png)

&emsp;&emsp;可以看到进程1和进程2的虚拟地址空间都被映射到了不连续的物理地址空间内(这个意义很大，如果有一天我们的连续物理地址空间不够，但是不连续的地址空间很多，如果没有这种技术，我们的程序就没有办法运行),甚至他们共用了一部分物理地址空间，这就是共享内存。

&emsp;&emsp;进程1的虚拟页VP2和VP3被交换到了磁盘中，在程序需要这两页的时候，Linux内核会产生一个缺页异常，然后异常管理程序会将其读到内存中。

&emsp;&emsp;这就是分页机制的原理，不过Linux中的分页机制的实现还是比较复杂的，使用的是一种与具体体系结构无关代码的四级页表机制——通过页全局目录，页上级目录，页中间目录，页表的分页机制来实现的。

![linux的分页机制](linux的分页机制.png)

&emsp;&emsp;分页机制的实现需要硬件的实现，这个硬件名字叫做**MMU**(Memory Management Unit)，他就是专门负责从虚拟地址到物理地址转换的，也就是从虚拟页找到物理页。